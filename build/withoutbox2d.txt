#include <SFML/Graphics.hpp>
#include <cmath>
#include <vector>
#include <memory>
#include <cstdlib> // For std::rand and std::srand
#include <ctime>   // For std::time

// Constants
const int WINDOW_WIDTH = 800;
const int WINDOW_HEIGHT = 600;
const float SUN_RADIUS = 50.0f;       // Radius of the Sun
const float SUN_MASS = 5000.0f;      // Mass of the Sun
const float G = 50.0f;               // Gravitational constant
const float PLANET_RADIUS = 10.0f;   // Radius of each planet
const float PLANET_MASS = 50.0f;     // Mass of each planet
const float COLLISION_THRESHOLD = SUN_RADIUS + 10.0f; // Collision distance

// Utility function to normalize a vector
sf::Vector2f normalize(const sf::Vector2f& v) {
    float length = std::sqrt(v.x * v.x + v.y * v.y);
    if (length != 0)
        return sf::Vector2f(v.x / length, v.y / length);
    return v;
}

// Class representing the Sun
class Sun {
private:
    sf::CircleShape shape;

public:
    Sun(sf::Vector2f position) {
        shape.setRadius(SUN_RADIUS);
        shape.setOrigin(SUN_RADIUS, SUN_RADIUS);
        shape.setFillColor(sf::Color::Yellow);
        shape.setPosition(position);
    }

    sf::CircleShape& getShape() { return shape; }
    sf::Vector2f getPosition() const { return shape.getPosition(); }
};

// Class representing a Planet
class Planet {
private:
    sf::CircleShape shape;
    sf::Vector2f velocity;
    sf::VertexArray trail;
    sf::Color color; // Random color for the planet and its trail

public:
    Planet(sf::Vector2f position, const sf::Vector2f& sunPosition)
        : trail(sf::LineStrip) {
        shape.setRadius(PLANET_RADIUS);
        shape.setOrigin(PLANET_RADIUS, PLANET_RADIUS);

        // Random color for the planet and trail
        color = sf::Color(std::rand() % 256, std::rand() % 256, std::rand() % 256);
        shape.setFillColor(color);

        shape.setPosition(position);

        // Initial velocity for counterclockwise orbit
        sf::Vector2f direction = position - sunPosition;
        float distance = std::sqrt(direction.x * direction.x + direction.y * direction.y);

        float speed = std::sqrt((G * SUN_MASS) / distance) * 6.f;

        // Perpendicular velocity for stable orbit
        sf::Vector2f tangentVelocity(-direction.y, direction.x);
        velocity = normalize(tangentVelocity) * speed;
    }

    sf::CircleShape& getShape() { return shape; }
    sf::Vector2f getPosition() const { return shape.getPosition(); }
    sf::Vector2f getVelocity() const { return velocity; }
    void setVelocity(const sf::Vector2f& newVelocity) { velocity = newVelocity; }

    void updateTrail() {
        trail.append(sf::Vertex(shape.getPosition(), color));
        if (trail.getVertexCount() > 100) {
            for (std::size_t i = 1; i < trail.getVertexCount(); ++i) {
                trail[i - 1] = trail[i];
            }
            trail.resize(100);
        }
    }

    void update(const sf::Vector2f& sunPosition, float deltaTime) {
        sf::Vector2f position = shape.getPosition();
        sf::Vector2f direction = sunPosition - position;
        float distance = std::sqrt(direction.x * direction.x + direction.y * direction.y);

        sf::Vector2f force = normalize(direction) * ((G * SUN_MASS * PLANET_MASS) / (distance * distance));

        velocity += force * deltaTime;
        shape.setPosition(position + velocity * deltaTime);
        updateTrail();
    }

    bool checkCollision(const sf::Vector2f& sunPosition) const {
        float distance = std::sqrt(
            std::pow(shape.getPosition().x - sunPosition.x, 2) +
            std::pow(shape.getPosition().y - sunPosition.y, 2));
        return distance < COLLISION_THRESHOLD;
    }

    void draw(sf::RenderWindow& window) {
        window.draw(trail);
        window.draw(shape);
    }
};

void handlePlanetCollisions(std::vector<std::unique_ptr<Planet>>& planets) {
    for (std::size_t i = 0; i < planets.size(); ++i) {
        for (std::size_t j = i + 1; j < planets.size(); ++j) {
            sf::Vector2f pos1 = planets[i]->getPosition();
            sf::Vector2f pos2 = planets[j]->getPosition();
            float distance = std::sqrt(std::pow(pos1.x - pos2.x, 2) + std::pow(pos1.y - pos2.y, 2));

            if (distance < 2 * PLANET_RADIUS) {
                // Swap velocities to simulate elastic collision
                sf::Vector2f vel1 = planets[i]->getVelocity();
                sf::Vector2f vel2 = planets[j]->getVelocity();
                planets[i]->setVelocity(vel2);
                planets[j]->setVelocity(vel1);
            }
        }
    }
}

int main() {
    sf::RenderWindow window(sf::VideoMode(WINDOW_WIDTH, WINDOW_HEIGHT), "Sun and Planets");
    window.setFramerateLimit(60);

    std::srand(static_cast<unsigned int>(std::time(nullptr)));

    Sun sun(sf::Vector2f(WINDOW_WIDTH / 2.0f, WINDOW_HEIGHT / 2.0f));

    std::vector<std::unique_ptr<Planet>> planets;

    sf::Clock clock;

    while (window.isOpen()) {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                window.close();

            if (event.type == sf::Event::MouseButtonPressed && event.mouseButton.button == sf::Mouse::Left) {
                sf::Vector2f mousePosition(event.mouseButton.x, event.mouseButton.y);
                planets.emplace_back(std::make_unique<Planet>(mousePosition, sun.getPosition()));
            }
        }

        float deltaTime = clock.restart().asSeconds();

        for (auto it = planets.begin(); it != planets.end();) {
            (*it)->update(sun.getPosition(), deltaTime);

            if ((*it)->checkCollision(sun.getPosition())) {
                it = planets.erase(it);
            }
            else {
                ++it;
            }
        }

        handlePlanetCollisions(planets);

        window.clear();
        window.draw(sun.getShape());
        for (auto& planet : planets) {
            planet->draw(window);
        }
        window.display();
    }

    return 0;
}
